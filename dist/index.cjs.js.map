{"version":3,"file":"index.cjs.js","sources":["../node_modules/umap/esm/index.js","../node_modules/uparser/esm/index.js","../node_modules/uarray/esm/index.js","../node_modules/uwire/esm/index.js","../node_modules/@ungap/create-content/esm/index.js","../node_modules/uhtml/esm/node.js","../node_modules/uhtml/esm/handlers.js","../node_modules/udomdiff/esm/index.js","../node_modules/uhandlers/esm/index.js","../node_modules/uhtml/esm/rabbit.js","../node_modules/uhtml/esm/index.js","../node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js","../node_modules/@vue/shared/dist/shared.esm-bundler.js","../src/index.js"],"sourcesContent":["export default _ => ({\n  // About: get: _.get.bind(_)\n  // It looks like WebKit/Safari didn't optimize bind at all,\n  // so that using bind slows it down by 60%.\n  // Firefox and Chrome are just fine in both cases,\n  // so let's use the approach that works fast everywhere ðŸ‘\n  get: key => _.get(key),\n  set: (key, value) => (_.set(key, value), value)\n});\n","const attr = /([^\\s\\\\>\"'=]+)\\s*=\\s*(['\"]?)$/;\nconst empty = /^(?:area|base|br|col|embed|hr|img|input|keygen|link|menuitem|meta|param|source|track|wbr)$/i;\nconst node = /<[a-z][^>]+$/i;\nconst notNode = />[^<>]*$/;\nconst selfClosing = /<([a-z]+[a-z0-9:._-]*)([^>]*?)(\\/>)/ig;\nconst trimEnd = /\\s+$/;\n\nconst isNode = (template, i) => (\n    0 < i-- && (\n    node.test(template[i]) || (\n      !notNode.test(template[i]) && isNode(template, i)\n    )\n  )\n);\n\nconst regular = (original, name, extra) => empty.test(name) ?\n                  original : `<${name}${extra.replace(trimEnd,'')}></${name}>`;\n\nexport default (template, prefix, svg) => {\n  const text = [];\n  const {length} = template;\n  for (let i = 1; i < length; i++) {\n    const chunk = template[i - 1];\n    text.push(attr.test(chunk) && isNode(template, i) ?\n      chunk.replace(\n        attr,\n        (_, $1, $2) => `${prefix}${i - 1}=${$2 || '\"'}${$1}${$2 ? '' : '\"'}`\n      ) :\n      `${chunk}<!--${prefix}${i - 1}-->`\n    );\n  }\n  text.push(template[length - 1]);\n  const output = text.join('').trim();\n  return svg ? output : output.replace(selfClosing, regular);\n};\n","const {isArray} = Array;\nconst {indexOf, slice} = [];\n\nexport {isArray, indexOf, slice};\n","import {slice} from 'uarray';\n\nconst ELEMENT_NODE = 1;\nconst nodeType = 111;\n\nconst remove = ({firstChild, lastChild}) => {\n  const range = document.createRange();\n  range.setStartAfter(firstChild);\n  range.setEndAfter(lastChild);\n  range.deleteContents();\n  return firstChild;\n};\n\nexport const diffable = (node, operation) => node.nodeType === nodeType ?\n  ((1 / operation) < 0 ?\n    (operation ? remove(node) : node.lastChild) :\n    (operation ? node.valueOf() : node.firstChild)) :\n  node\n;\n\nexport const persistent = fragment => {\n  const {childNodes} = fragment;\n  const {length} = childNodes;\n  if (length < 2)\n    return length ? childNodes[0] : fragment;\n  const nodes = slice.call(childNodes, 0);\n  const firstChild = nodes[0];\n  const lastChild = nodes[length - 1];\n  return {\n    ELEMENT_NODE,\n    nodeType,\n    firstChild,\n    lastChild,\n    valueOf() {\n      if (childNodes.length !== length) {\n        let i = 0;\n        while (i < length)\n          fragment.appendChild(nodes[i++]);\n      }\n      return fragment;\n    }\n  };\n};\n","/*! (c) Andrea Giammarchi - ISC */\nvar createContent = (function (document) {'use strict';\n  var FRAGMENT = 'fragment';\n  var TEMPLATE = 'template';\n  var HAS_CONTENT = 'content' in create(TEMPLATE);\n\n  var createHTML = HAS_CONTENT ?\n    function (html) {\n      var template = create(TEMPLATE);\n      template.innerHTML = html;\n      return template.content;\n    } :\n    function (html) {\n      var content = create(FRAGMENT);\n      var template = create(TEMPLATE);\n      var childNodes = null;\n      if (/^[^\\S]*?<(col(?:group)?|t(?:head|body|foot|r|d|h))/i.test(html)) {\n        var selector = RegExp.$1;\n        template.innerHTML = '<table>' + html + '</table>';\n        childNodes = template.querySelectorAll(selector);\n      } else {\n        template.innerHTML = html;\n        childNodes = template.childNodes;\n      }\n      append(content, childNodes);\n      return content;\n    };\n\n  return function createContent(markup, type) {\n    return (type === 'svg' ? createSVG : createHTML)(markup);\n  };\n\n  function append(root, childNodes) {\n    var length = childNodes.length;\n    while (length--)\n      root.appendChild(childNodes[0]);\n  }\n\n  function create(element) {\n    return element === FRAGMENT ?\n      document.createDocumentFragment() :\n      document.createElementNS('http://www.w3.org/1999/xhtml', element);\n  }\n\n  // it could use createElementNS when hasNode is there\n  // but this fallback is equally fast and easier to maintain\n  // it is also battle tested already in all IE\n  function createSVG(svg) {\n    var content = create(FRAGMENT);\n    var template = create('div');\n    template.innerHTML = '<svg xmlns=\"http://www.w3.org/2000/svg\">' + svg + '</svg>';\n    append(content, template.firstChild.childNodes);\n    return content;\n  }\n\n}(document));\nexport default createContent;\n","import createContent from '@ungap/create-content';\nimport {indexOf} from 'uarray';\n\n// from a generic path, retrieves the exact targeted node\nexport const reducePath = ({childNodes}, i) => childNodes[i];\n\n// from a fragment container, create an array of indexes\n// related to its child nodes, so that it's possible\n// to retrieve later on exact node via reducePath\nexport const createPath = node => {\n  const path = [];\n  let {parentNode} = node;\n  while (parentNode) {\n    path.push(indexOf.call(parentNode.childNodes, node));\n    node = parentNode;\n    parentNode = node.parentNode;\n  }\n  return path;\n};\n\nconst {createTreeWalker, importNode} = document;\nexport {createTreeWalker, importNode};\n\n// this \"hack\" tells the library if the browser is IE11 or old Edge\nconst isImportNodeLengthWrong = importNode.length != 1;\n\n// IE11 and old Edge discard empty nodes when cloning, potentially\n// resulting in broken paths to find updates. The workaround here\n// is to import once, upfront, the fragment that will be cloned\n// later on, so that paths are retrieved from one already parsed,\n// hence without missing child nodes once re-cloned.\nexport const createFragment = isImportNodeLengthWrong ?\n  (text, type, normalize) => importNode.call(\n    document,\n    createContent(text, type, normalize),\n    true\n  ) :\n  createContent;\n\n// IE11 and old Edge have a different createTreeWalker signature that\n// has been deprecated in other browsers. This export is needed only\n// to guarantee the TreeWalker doesn't show warnings and, ultimately, works\nexport const createWalker = isImportNodeLengthWrong ?\n  fragment => createTreeWalker.call(document, fragment, 1 | 128, null, false) :\n  fragment => createTreeWalker.call(document, fragment, 1 | 128);\n","import {isArray, slice} from 'uarray';\nimport udomdiff from 'udomdiff';\nimport {aria, attribute, boolean, event, ref, setter, text} from 'uhandlers';\nimport {diffable} from 'uwire';\n\nimport {reducePath} from './node.js';\n\n// this helper avoid code bloat around handleAnything() callback\nconst diff = (comment, oldNodes, newNodes) => udomdiff(\n  comment.parentNode,\n  // TODO: there is a possible edge case where a node has been\n  //       removed manually, or it was a keyed one, attached\n  //       to a shared reference between renders.\n  //       In this case udomdiff might fail at removing such node\n  //       as its parent won't be the expected one.\n  //       The best way to avoid this issue is to filter oldNodes\n  //       in search of those not live, or not in the current parent\n  //       anymore, but this would require both a change to uwire,\n  //       exposing a parentNode from the firstChild, as example,\n  //       but also a filter per each diff that should exclude nodes\n  //       that are not in there, penalizing performance quite a lot.\n  //       As this has been also a potential issue with domdiff,\n  //       and both lighterhtml and hyperHTML might fail with this\n  //       very specific edge case, I might as well document this possible\n  //       \"diffing shenanigan\" and call it a day.\n  oldNodes,\n  newNodes,\n  diffable,\n  comment\n);\n\n// if an interpolation represents a comment, the whole\n// diffing will be related to such comment.\n// This helper is in charge of understanding how the new\n// content for such interpolation/hole should be updated\nconst handleAnything = comment => {\n  let oldValue, text, nodes = [];\n  const anyContent = newValue => {\n    switch (typeof newValue) {\n      // primitives are handled as text content\n      case 'string':\n      case 'number':\n      case 'boolean':\n        if (oldValue !== newValue) {\n          oldValue = newValue;\n          if (text)\n            text.nodeValue = newValue;\n          else\n            text = document.createTextNode(newValue);\n          nodes = diff(comment, nodes, [text]);\n        }\n        break;\n      case 'function':\n        anyContent(newValue(comment));\n        break;\n      // null, and undefined are used to cleanup previous content\n      case 'object':\n      case 'undefined':\n        if (newValue == null) {\n          if (oldValue != newValue) {\n            oldValue = newValue;\n            nodes = diff(comment, nodes, []);\n          }\n          break;\n        }\n        // arrays and nodes have a special treatment\n        if (isArray(newValue)) {\n          oldValue = newValue;\n          // arrays can be used to cleanup, if empty\n          if (newValue.length === 0)\n            nodes = diff(comment, nodes, []);\n          // or diffed, if these contains nodes or \"wires\"\n          else if (typeof newValue[0] === 'object')\n            nodes = diff(comment, nodes, newValue);\n          // in all other cases the content is stringified as is\n          else\n            anyContent(String(newValue));\n          break;\n        }\n        // if the new value is a DOM node, or a wire, and it's\n        // different from the one already live, then it's diffed.\n        // if the node is a fragment, it's appended once via its childNodes\n        // There is no `else` here, meaning if the content\n        // is not expected one, nothing happens, as easy as that.\n        if ('ELEMENT_NODE' in newValue && oldValue !== newValue) {\n          oldValue = newValue;\n          nodes = diff(\n            comment,\n            nodes,\n            newValue.nodeType === 11 ?\n              slice.call(newValue.childNodes) :\n              [newValue]\n          );\n        }\n    }\n  };\n  return anyContent;\n};\n\n// attributes can be:\n//  * ref=${...}      for hooks and other purposes\n//  * aria=${...}     for aria attributes\n//  * ?boolean=${...} for boolean attributes\n//  * .dataset=${...} for dataset related attributes\n//  * .setter=${...}  for Custom Elements setters or nodes with setters\n//                    such as buttons, details, options, select, etc\n//  * onevent=${...}  to automatically handle event listeners\n//  * generic=${...}  to handle an attribute just like an attribute\nconst handleAttribute = (node, name/*, svg*/) => {\n  switch (name[0]) {\n    case '?': return boolean(node, name.slice(1), false);\n    case '.': return setter(node, name.slice(1));\n    case 'o': if (name[1] === 'n') return event(node, name);\n  }\n\n  switch (name) {\n    case 'ref': return ref(node);\n    case 'aria': return aria(node);\n  }\n\n  return attribute(node, name/*, svg*/);\n};\n\n// each mapped update carries the update type and its path\n// the type is either node, attribute, or text, while\n// the path is how to retrieve the related node to update.\n// In the attribute case, the attribute name is also carried along.\nexport function handlers(options) {\n  const {type, path} = options;\n  const node = path.reduceRight(reducePath, this);\n  return type === 'node' ?\n    handleAnything(node) :\n    (type === 'attr' ?\n      handleAttribute(node, options.name/*, options.svg*/) :\n      text(node));\n};\n","/**\n * ISC License\n *\n * Copyright (c) 2020, Andrea Giammarchi, @WebReflection\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\n * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\n * AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\n * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\n * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE\n * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/**\n * @param {Node} parentNode The container where children live\n * @param {Node[]} a The list of current/live children\n * @param {Node[]} b The list of future children\n * @param {(entry: Node, action: number) => Node} get\n * The callback invoked per each entry related DOM operation.\n * @param {Node} [before] The optional node used as anchor to insert before.\n * @returns {Node[]} The same list of future children.\n */\nexport default (parentNode, a, b, get, before) => {\n  const bLength = b.length;\n  let aEnd = a.length;\n  let bEnd = bLength;\n  let aStart = 0;\n  let bStart = 0;\n  let map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    // append head, tail, or nodes in between: fast path\n    if (aEnd === aStart) {\n      // we could be in a situation where the rest of nodes that\n      // need to be added are not at the end, and in such case\n      // the node to `insertBefore`, if the index is more than 0\n      // must be retrieved, otherwise it's gonna be the first item.\n      const node = bEnd < bLength ?\n        (bStart ?\n          (get(b[bStart - 1], -0).nextSibling) :\n          get(b[bEnd - bStart], 0)) :\n        before;\n      while (bStart < bEnd)\n        parentNode.insertBefore(get(b[bStart++], 1), node);\n    }\n    // remove head or tail: fast path\n    else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        // remove the node only if it's unknown or not live\n        if (!map || !map.has(a[aStart]))\n          parentNode.removeChild(get(a[aStart], -1));\n        aStart++;\n      }\n    }\n    // same node: fast path\n    else if (a[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n    }\n    // same tail: fast path\n    else if (a[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    // The once here single last swap \"fast path\" has been removed in v1.1.0\n    // https://github.com/WebReflection/udomdiff/blob/single-final-swap/esm/index.js#L69-L85\n    // reverse swap: also fast path\n    else if (\n      a[aStart] === b[bEnd - 1] &&\n      b[bStart] === a[aEnd - 1]\n    ) {\n      // this is a \"shrink\" operation that could happen in these cases:\n      // [1, 2, 3, 4, 5]\n      // [1, 4, 3, 2, 5]\n      // or asymmetric too\n      // [1, 2, 3, 4, 5]\n      // [1, 2, 3, 5, 6, 4]\n      const node = get(a[--aEnd], -1).nextSibling;\n      parentNode.insertBefore(\n        get(b[bStart++], 1),\n        get(a[aStart++], -1).nextSibling\n      );\n      parentNode.insertBefore(get(b[--bEnd], 1), node);\n      // mark the future index as identical (yeah, it's dirty, but cheap ðŸ‘)\n      // The main reason to do this, is that when a[aEnd] will be reached,\n      // the loop will likely be on the fast path, as identical to b[bEnd].\n      // In the best case scenario, the next loop will skip the tail,\n      // but in the worst one, this node will be considered as already\n      // processed, bailing out pretty quickly from the map index check\n      a[aEnd] = b[bEnd];\n    }\n    // map based fallback, \"slow\" path\n    else {\n      // the map requires an O(bEnd - bStart) operation once\n      // to store all future nodes indexes for later purposes.\n      // In the worst case scenario, this is a full O(N) cost,\n      // and such scenario happens at least when all nodes are different,\n      // but also if both first and last items of the lists are different\n      if (!map) {\n        map = new Map;\n        let i = bStart;\n        while (i < bEnd)\n          map.set(b[i], i++);\n      }\n      // if it's a future node, hence it needs some handling\n      if (map.has(a[aStart])) {\n        // grab the index of such node, 'cause it might have been processed\n        const index = map.get(a[aStart]);\n        // if it's not already processed, look on demand for the next LCS\n        if (bStart < index && index < bEnd) {\n          let i = aStart;\n          // counts the amount of nodes that are the same in the future\n          let sequence = 1;\n          while (++i < aEnd && i < bEnd && map.get(a[i]) === (index + sequence))\n            sequence++;\n          // effort decision here: if the sequence is longer than replaces\n          // needed to reach such sequence, which would brings again this loop\n          // to the fast path, prepend the difference before a sequence,\n          // and move only the future list index forward, so that aStart\n          // and bStart will be aligned again, hence on the fast path.\n          // An example considering aStart and bStart are both 0:\n          // a: [1, 2, 3, 4]\n          // b: [7, 1, 2, 3, 6]\n          // this would place 7 before 1 and, from that time on, 1, 2, and 3\n          // will be processed at zero cost\n          if (sequence > (index - bStart)) {\n            const node = get(a[aStart], 0);\n            while (bStart < index)\n              parentNode.insertBefore(get(b[bStart++], 1), node);\n          }\n          // if the effort wasn't good enough, fallback to a replace,\n          // moving both source and target indexes forward, hoping that some\n          // similar node will be found later on, to go back to the fast path\n          else {\n            parentNode.replaceChild(\n              get(b[bStart++], 1),\n              get(a[aStart++], -1)\n            );\n          }\n        }\n        // otherwise move the source forward, 'cause there's nothing to do\n        else\n          aStart++;\n      }\n      // this node has no meaning in the future list, so it's more than safe\n      // to remove it, and check the next live node out instead, meaning\n      // that only the live list index should be forwarded\n      else\n        parentNode.removeChild(get(a[aStart++], -1));\n    }\n  }\n  return b;\n};\n","import {isArray} from 'uarray';\n\nexport const aria = node => values => {\n  for (const key in values) {\n    const name = key === 'role' ? key : `aria-${key}`;\n    const value = values[key];\n    if (value == null)\n      node.removeAttribute(name);\n    else\n      node.setAttribute(name, value);\n  }\n};\n\nexport const attribute = (node, name) => {\n  let oldValue, orphan = true;\n  const attributeNode = document.createAttributeNS(null, name);\n  return newValue => {\n    if (oldValue !== newValue) {\n      oldValue = newValue;\n      if (oldValue == null) {\n        if (!orphan) {\n          node.removeAttributeNode(attributeNode);\n          orphan = true;\n        }\n      }\n      else {\n        attributeNode.value = newValue;\n        if (orphan) {\n          node.setAttributeNodeNS(attributeNode);\n          orphan = false;\n        }\n      }\n    }\n  };\n};\n\nexport const boolean = (node, key, oldValue) => newValue => {\n  if (oldValue !== !!newValue) {\n    // when IE won't be around anymore ...\n    // node.toggleAttribute(key, oldValue = !!newValue);\n    if ((oldValue = !!newValue))\n      node.setAttribute(key, '');\n    else\n      node.removeAttribute(key);\n  }\n};\n\nexport const data = ({dataset}) => values => {\n  for (const key in values) {\n    const value = values[key];\n    if (value == null)\n      delete dataset[key];\n    else\n      dataset[key] = value;\n  }\n};\n\nexport const event = (node, name) => {\n  let oldValue, type = name.slice(2);\n  if (!(name in node) && name.toLowerCase() in node)\n    type = type.toLowerCase();\n  return newValue => {\n    const info = isArray(newValue) ? newValue : [newValue, false];\n    if (oldValue !== info[0]) {\n      if (oldValue)\n        node.removeEventListener(type, oldValue, info[1]);\n      if (oldValue = info[0])\n        node.addEventListener(type, oldValue, info[1]);\n    }\n  };\n};\n\nexport const ref = node => value => {\n  if (typeof value === 'function')\n    value(node);\n  else\n    value.current = node;\n};\n\nexport const setter = (node, key) => key === 'dataset' ?\n  data(node) :\n  value => {\n    node[key] = value;\n  };\n\nexport const text = node => {\n  let oldValue;\n  return newValue => {\n    if (oldValue != newValue) {\n      oldValue = newValue;\n      node.textContent = newValue == null ? '' : newValue;\n    }\n  };\n};\n","import umap from 'umap';\nimport instrument from 'uparser';\nimport {isArray} from 'uarray';\nimport {persistent} from 'uwire';\n\nimport {handlers} from './handlers.js';\nimport {createFragment, createPath, createWalker, importNode} from './node.js';\n\n// the prefix is used to identify either comments, attributes, or nodes\n// that contain the related unique id. In the attribute cases\n// isÂµX=\"attribute-name\" will be used to map current X update to that\n// attribute name, while comments will be like <!--isÂµX-->, to map\n// the update to that specific comment node, hence its parent.\n// style and textarea will have <!--isÂµX--> text content, and are handled\n// directly through text-only updates.\nconst prefix = 'isÂµ';\n\n// Template Literals are unique per scope and static, meaning a template\n// should be parsed once, and once only, as it will always represent the same\n// content, within the exact same amount of updates each time.\n// This cache relates each template to its unique content and updates.\nconst cache = umap(new WeakMap);\n\n// a RegExp that helps checking nodes that cannot contain comments\nconst textOnly = /^(?:plaintext|script|style|textarea|title|xmp)$/i;\n\nexport const createCache = () => ({\n  stack: [],    // each template gets a stack for each interpolation \"hole\"\n\n  entry: null,  // each entry contains details, such as:\n                //  * the template that is representing\n                //  * the type of node it represents (html or svg)\n                //  * the content fragment with all nodes\n                //  * the list of updates per each node (template holes)\n                //  * the \"wired\" node or fragment that will get updates\n                // if the template or type are different from the previous one\n                // the entry gets re-created each time\n\n  wire: null    // each rendered node represent some wired content and\n                // this reference to the latest one. If different, the node\n                // will be cleaned up and the new \"wire\" will be appended\n});\n\n// the entry stored in the rendered node cache, and per each \"hole\"\nconst createEntry = (type, template) => {\n  const {content, updates} = mapUpdates(type, template);\n  return {type, template, content, updates, wire: null};\n};\n\n// a template is instrumented to be able to retrieve where updates are needed.\n// Each unique template becomes a fragment, cloned once per each other\n// operation based on the same template, i.e. data => html`<p>${data}</p>`\nconst mapTemplate = (type, template) => {\n  const text = instrument(template, prefix, type === 'svg');\n  const content = createFragment(text, type);\n  // once instrumented and reproduced as fragment, it's crawled\n  // to find out where each update is in the fragment tree\n  const tw = createWalker(content);\n  const nodes = [];\n  const length = template.length - 1;\n  let i = 0;\n  // updates are searched via unique names, linearly increased across the tree\n  // <div isÂµ0=\"attr\" isÂµ1=\"other\"><!--isÂµ2--><style><!--isÂµ3--</style></div>\n  let search = `${prefix}${i}`;\n  while (i < length) {\n    const node = tw.nextNode();\n    // if not all updates are bound but there's nothing else to crawl\n    // it means that there is something wrong with the template.\n    if (!node)\n      throw `bad template: ${text}`;\n    // if the current node is a comment, and it contains isÂµX\n    // it means the update should take care of any content\n    if (node.nodeType === 8) {\n      // The only comments to be considered are those\n      // which content is exactly the same as the searched one.\n      if (node.nodeValue === search) {\n        nodes.push({type: 'node', path: createPath(node)});\n        search = `${prefix}${++i}`;\n      }\n    }\n    else {\n      // if the node is not a comment, loop through all its attributes\n      // named isÂµX and relate attribute updates to this node and the\n      // attribute name, retrieved through node.getAttribute(\"isÂµX\")\n      // the isÂµX attribute will be removed as irrelevant for the layout\n      // let svg = -1;\n      while (node.hasAttribute(search)) {\n        nodes.push({\n          type: 'attr',\n          path: createPath(node),\n          name: node.getAttribute(search),\n          //svg: svg < 0 ? (svg = ('ownerSVGElement' in node ? 1 : 0)) : svg\n        });\n        node.removeAttribute(search);\n        search = `${prefix}${++i}`;\n      }\n      // if the node was a style, textarea, or others, check its content\n      // and if it is <!--isÂµX--> then update tex-only this node\n      if (\n        textOnly.test(node.tagName) &&\n        node.textContent.trim() === `<!--${search}-->`\n      ){\n        node.textContent = '';\n        nodes.push({type: 'text', path: createPath(node)});\n        search = `${prefix}${++i}`;\n      }\n    }\n  }\n  // once all nodes to update, or their attributes, are known, the content\n  // will be cloned in the future to represent the template, and all updates\n  // related to such content retrieved right away without needing to re-crawl\n  // the exact same template, and its content, more than once.\n  return {content, nodes};\n};\n\n// if a template is unknown, perform the previous mapping, otherwise grab\n// its details such as the fragment with all nodes, and updates info.\nconst mapUpdates = (type, template) => {\n  const {content, nodes} = (\n    cache.get(template) ||\n    cache.set(template, mapTemplate(type, template))\n  );\n  // clone deeply the fragment\n  const fragment = importNode.call(document, content, true);\n  // and relate an update handler per each node that needs one\n  const updates = nodes.map(handlers, fragment);\n  // return the fragment and all updates to use within its nodes\n  return {content: fragment, updates};\n};\n\n// as html and svg can be nested calls, but no parent node is known\n// until rendered somewhere, the unroll operation is needed to\n// discover what to do with each interpolation, which will result\n// into an update operation.\nexport const unroll = (info, {type, template, values}) => {\n  const {length} = values;\n  // interpolations can contain holes and arrays, so these need\n  // to be recursively discovered\n  unrollValues(info, values, length);\n  let {entry} = info;\n  // if the cache entry is either null or different from the template\n  // and the type this unroll should resolve, create a new entry\n  // assigning a new content fragment and the list of updates.\n  if (!entry || (entry.template !== template || entry.type !== type))\n    info.entry = (entry = createEntry(type, template));\n  const {content, updates, wire} = entry;\n  // even if the fragment and its nodes is not live yet,\n  // it is already possible to update via interpolations values.\n  for (let i = 0; i < length; i++)\n    updates[i](values[i]);\n  // if the entry was new, or representing a different template or type,\n  // create a new persistent entity to use during diffing.\n  // This is simply a DOM node, when the template has a single container,\n  // as in `<p></p>`, or a \"wire\" in `<p></p><p></p>` and similar cases.\n  return wire || (entry.wire = persistent(content));\n};\n\n// the stack retains, per each interpolation value, the cache\n// related to each interpolation value, or null, if the render\n// was conditional and the value is not special (Array or Hole)\nconst unrollValues = ({stack}, values, length) => {\n  for (let i = 0; i < length; i++) {\n    const hole = values[i];\n    // each Hole gets unrolled and re-assigned as value\n    // so that domdiff will deal with a node/wire, not with a hole\n    if (hole instanceof Hole)\n      values[i] = unroll(\n        stack[i] || (stack[i] = createCache()),\n        hole\n      );\n    // arrays are recursively resolved so that each entry will contain\n    // also a DOM node or a wire, hence it can be diffed if/when needed\n    else if (isArray(hole))\n      unrollValues(\n        stack[i] || (stack[i] = createCache()),\n        hole,\n        hole.length\n      );\n    // if the value is nothing special, the stack doesn't need to retain data\n    // this is useful also to cleanup previously retained data, if the value\n    // was a Hole, or an Array, but not anymore, i.e.:\n    // const update = content => html`<div>${content}</div>`;\n    // update(listOfItems); update(null); update(html`hole`)\n    else\n      stack[i] = null;\n  }\n  if (length < stack.length)\n    stack.splice(length);\n};\n\n/**\n * Holds all details wrappers needed to render the content further on.\n * @constructor\n * @param {string} type The hole type, either `html` or `svg`.\n * @param {string[]} template The template literals used to the define the content.\n * @param {Array} values Zero, one, or more interpolated values to render.\n */\nexport function Hole(type, template, values) {\n  this.type = type;\n  this.template = template;\n  this.values = values;\n};\n","import umap from 'umap';\nimport {Hole, createCache, unroll} from './rabbit.js';\n\nconst {create, defineProperties} = Object;\n\n// both `html` and `svg` template literal tags are polluted\n// with a `for(ref[, id])` and a `node` tag too\nconst tag = type => {\n  // both `html` and `svg` tags have their own cache\n  const keyed = umap(new WeakMap);\n  // keyed operations always re-use the same cache and unroll\n  // the template and its interpolations right away\n  const fixed = cache => (template, ...values) => unroll(\n    cache,\n    {type, template, values}\n  );\n  return defineProperties(\n    // non keyed operations are recognized as instance of Hole\n    // during the \"unroll\", recursively resolved and updated\n    (template, ...values) => new Hole(type, template, values),\n    {\n      for: {\n        // keyed operations need a reference object, usually the parent node\n        // which is showing keyed results, and optionally a unique id per each\n        // related node, handy with JSON results and mutable list of objects\n        // that usually carry a unique identifier\n        value(ref, id) {\n          const memo = keyed.get(ref) || keyed.set(ref, create(null));\n          return memo[id] || (memo[id] = fixed(createCache()));\n        }\n      },\n      node: {\n        // it is possible to create one-off content out of the box via node tag\n        // this might return the single created node, or a fragment with all\n        // nodes present at the root level and, of course, their child nodes\n        value: (template, ...values) => unroll(\n          createCache(),\n          {type, template, values}\n        ).valueOf()\n      }\n    }\n  );\n};\n\n// each rendered node gets its own cache\nconst cache = umap(new WeakMap);\n\n// rendering means understanding what `html` or `svg` tags returned\n// and it relates a specific node to its own unique cache.\n// Each time the content to render changes, the node is cleaned up\n// and the new new content is appended, and if such content is a Hole\n// then it's \"unrolled\" to resolve all its inner nodes.\nconst render = (where, what) => {\n  const hole = typeof what === 'function' ? what() : what;\n  const info = cache.get(where) || cache.set(where, createCache());\n  const wire = hole instanceof Hole ? unroll(info, hole) : hole;\n  if (wire !== info.wire) {\n    info.wire = wire;\n    where.textContent = '';\n    // valueOf() simply returns the node itself, but in case it was a \"wire\"\n    // it will eventually re-append all nodes to its fragment so that such\n    // fragment can be re-appended many times in a meaningful way\n    // (wires are basically persistent fragments facades with special behavior)\n    where.appendChild(wire.valueOf());\n  }\n  return where;\n};\n\nconst html = tag('html');\nconst svg = tag('svg');\n\nexport {Hole, render, html, svg};\n","import { EMPTY_OBJ, isArray, isMap, isIntegerKey, isSymbol, extend, hasOwn, isObject, hasChanged, capitalize, toRawType, def, isFunction, NOOP } from '@vue/shared';\n\nconst targetMap = new WeakMap();\r\nconst effectStack = [];\r\nlet activeEffect;\r\nconst ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'iterate' : '');\r\nconst MAP_KEY_ITERATE_KEY = Symbol((process.env.NODE_ENV !== 'production') ? 'Map key iterate' : '');\r\nfunction isEffect(fn) {\r\n    return fn && fn._isEffect === true;\r\n}\r\nfunction effect(fn, options = EMPTY_OBJ) {\r\n    if (isEffect(fn)) {\r\n        fn = fn.raw;\r\n    }\r\n    const effect = createReactiveEffect(fn, options);\r\n    if (!options.lazy) {\r\n        effect();\r\n    }\r\n    return effect;\r\n}\r\nfunction stop(effect) {\r\n    if (effect.active) {\r\n        cleanup(effect);\r\n        if (effect.options.onStop) {\r\n            effect.options.onStop();\r\n        }\r\n        effect.active = false;\r\n    }\r\n}\r\nlet uid = 0;\r\nfunction createReactiveEffect(fn, options) {\r\n    const effect = function reactiveEffect() {\r\n        if (!effect.active) {\r\n            return options.scheduler ? undefined : fn();\r\n        }\r\n        if (!effectStack.includes(effect)) {\r\n            cleanup(effect);\r\n            try {\r\n                enableTracking();\r\n                effectStack.push(effect);\r\n                activeEffect = effect;\r\n                return fn();\r\n            }\r\n            finally {\r\n                effectStack.pop();\r\n                resetTracking();\r\n                activeEffect = effectStack[effectStack.length - 1];\r\n            }\r\n        }\r\n    };\r\n    effect.id = uid++;\r\n    effect.allowRecurse = !!options.allowRecurse;\r\n    effect._isEffect = true;\r\n    effect.active = true;\r\n    effect.raw = fn;\r\n    effect.deps = [];\r\n    effect.options = options;\r\n    return effect;\r\n}\r\nfunction cleanup(effect) {\r\n    const { deps } = effect;\r\n    if (deps.length) {\r\n        for (let i = 0; i < deps.length; i++) {\r\n            deps[i].delete(effect);\r\n        }\r\n        deps.length = 0;\r\n    }\r\n}\r\nlet shouldTrack = true;\r\nconst trackStack = [];\r\nfunction pauseTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = false;\r\n}\r\nfunction enableTracking() {\r\n    trackStack.push(shouldTrack);\r\n    shouldTrack = true;\r\n}\r\nfunction resetTracking() {\r\n    const last = trackStack.pop();\r\n    shouldTrack = last === undefined ? true : last;\r\n}\r\nfunction track(target, type, key) {\r\n    if (!shouldTrack || activeEffect === undefined) {\r\n        return;\r\n    }\r\n    let depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        targetMap.set(target, (depsMap = new Map()));\r\n    }\r\n    let dep = depsMap.get(key);\r\n    if (!dep) {\r\n        depsMap.set(key, (dep = new Set()));\r\n    }\r\n    if (!dep.has(activeEffect)) {\r\n        dep.add(activeEffect);\r\n        activeEffect.deps.push(dep);\r\n        if ((process.env.NODE_ENV !== 'production') && activeEffect.options.onTrack) {\r\n            activeEffect.options.onTrack({\r\n                effect: activeEffect,\r\n                target,\r\n                type,\r\n                key\r\n            });\r\n        }\r\n    }\r\n}\r\nfunction trigger(target, type, key, newValue, oldValue, oldTarget) {\r\n    const depsMap = targetMap.get(target);\r\n    if (!depsMap) {\r\n        // never been tracked\r\n        return;\r\n    }\r\n    const effects = new Set();\r\n    const add = (effectsToAdd) => {\r\n        if (effectsToAdd) {\r\n            effectsToAdd.forEach(effect => {\r\n                if (effect !== activeEffect || effect.allowRecurse) {\r\n                    effects.add(effect);\r\n                }\r\n            });\r\n        }\r\n    };\r\n    if (type === \"clear\" /* CLEAR */) {\r\n        // collection being cleared\r\n        // trigger all effects for target\r\n        depsMap.forEach(add);\r\n    }\r\n    else if (key === 'length' && isArray(target)) {\r\n        depsMap.forEach((dep, key) => {\r\n            if (key === 'length' || key >= newValue) {\r\n                add(dep);\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        // schedule runs for SET | ADD | DELETE\r\n        if (key !== void 0) {\r\n            add(depsMap.get(key));\r\n        }\r\n        // also run for iteration key on ADD | DELETE | Map.SET\r\n        switch (type) {\r\n            case \"add\" /* ADD */:\r\n                if (!isArray(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                    if (isMap(target)) {\r\n                        add(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                else if (isIntegerKey(key)) {\r\n                    // new index added to array -> length changes\r\n                    add(depsMap.get('length'));\r\n                }\r\n                break;\r\n            case \"delete\" /* DELETE */:\r\n                if (!isArray(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                    if (isMap(target)) {\r\n                        add(depsMap.get(MAP_KEY_ITERATE_KEY));\r\n                    }\r\n                }\r\n                break;\r\n            case \"set\" /* SET */:\r\n                if (isMap(target)) {\r\n                    add(depsMap.get(ITERATE_KEY));\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    const run = (effect) => {\r\n        if ((process.env.NODE_ENV !== 'production') && effect.options.onTrigger) {\r\n            effect.options.onTrigger({\r\n                effect,\r\n                target,\r\n                key,\r\n                type,\r\n                newValue,\r\n                oldValue,\r\n                oldTarget\r\n            });\r\n        }\r\n        if (effect.options.scheduler) {\r\n            effect.options.scheduler(effect);\r\n        }\r\n        else {\r\n            effect();\r\n        }\r\n    };\r\n    effects.forEach(run);\r\n}\n\nconst builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol)\r\n    .map(key => Symbol[key])\r\n    .filter(isSymbol));\r\nconst get = /*#__PURE__*/ createGetter();\r\nconst shallowGet = /*#__PURE__*/ createGetter(false, true);\r\nconst readonlyGet = /*#__PURE__*/ createGetter(true);\r\nconst shallowReadonlyGet = /*#__PURE__*/ createGetter(true, true);\r\nconst arrayInstrumentations = {};\r\n['includes', 'indexOf', 'lastIndexOf'].forEach(key => {\r\n    const method = Array.prototype[key];\r\n    arrayInstrumentations[key] = function (...args) {\r\n        const arr = toRaw(this);\r\n        for (let i = 0, l = this.length; i < l; i++) {\r\n            track(arr, \"get\" /* GET */, i + '');\r\n        }\r\n        // we run the method using the original args first (which may be reactive)\r\n        const res = method.apply(arr, args);\r\n        if (res === -1 || res === false) {\r\n            // if that didn't work, run it again using raw values.\r\n            return method.apply(arr, args.map(toRaw));\r\n        }\r\n        else {\r\n            return res;\r\n        }\r\n    };\r\n});\r\n['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {\r\n    const method = Array.prototype[key];\r\n    arrayInstrumentations[key] = function (...args) {\r\n        pauseTracking();\r\n        const res = method.apply(this, args);\r\n        resetTracking();\r\n        return res;\r\n    };\r\n});\r\nfunction createGetter(isReadonly = false, shallow = false) {\r\n    return function get(target, key, receiver) {\r\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_raw\" /* RAW */ &&\r\n            receiver === (isReadonly ? readonlyMap : reactiveMap).get(target)) {\r\n            return target;\r\n        }\r\n        const targetIsArray = isArray(target);\r\n        if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {\r\n            return Reflect.get(arrayInstrumentations, key, receiver);\r\n        }\r\n        const res = Reflect.get(target, key, receiver);\r\n        if (isSymbol(key)\r\n            ? builtInSymbols.has(key)\r\n            : key === `__proto__` || key === `__v_isRef`) {\r\n            return res;\r\n        }\r\n        if (!isReadonly) {\r\n            track(target, \"get\" /* GET */, key);\r\n        }\r\n        if (shallow) {\r\n            return res;\r\n        }\r\n        if (isRef(res)) {\r\n            // ref unwrapping - does not apply for Array + integer key.\r\n            const shouldUnwrap = !targetIsArray || !isIntegerKey(key);\r\n            return shouldUnwrap ? res.value : res;\r\n        }\r\n        if (isObject(res)) {\r\n            // Convert returned value into a proxy as well. we do the isObject check\r\n            // here to avoid invalid value warning. Also need to lazy access readonly\r\n            // and reactive here to avoid circular dependency.\r\n            return isReadonly ? readonly(res) : reactive(res);\r\n        }\r\n        return res;\r\n    };\r\n}\r\nconst set = /*#__PURE__*/ createSetter();\r\nconst shallowSet = /*#__PURE__*/ createSetter(true);\r\nfunction createSetter(shallow = false) {\r\n    return function set(target, key, value, receiver) {\r\n        const oldValue = target[key];\r\n        if (!shallow) {\r\n            value = toRaw(value);\r\n            if (!isArray(target) && isRef(oldValue) && !isRef(value)) {\r\n                oldValue.value = value;\r\n                return true;\r\n            }\r\n        }\r\n        const hadKey = isArray(target) && isIntegerKey(key)\r\n            ? Number(key) < target.length\r\n            : hasOwn(target, key);\r\n        const result = Reflect.set(target, key, value, receiver);\r\n        // don't trigger if target is something up in the prototype chain of original\r\n        if (target === toRaw(receiver)) {\r\n            if (!hadKey) {\r\n                trigger(target, \"add\" /* ADD */, key, value);\r\n            }\r\n            else if (hasChanged(value, oldValue)) {\r\n                trigger(target, \"set\" /* SET */, key, value, oldValue);\r\n            }\r\n        }\r\n        return result;\r\n    };\r\n}\r\nfunction deleteProperty(target, key) {\r\n    const hadKey = hasOwn(target, key);\r\n    const oldValue = target[key];\r\n    const result = Reflect.deleteProperty(target, key);\r\n    if (result && hadKey) {\r\n        trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction has(target, key) {\r\n    const result = Reflect.has(target, key);\r\n    if (!isSymbol(key) || !builtInSymbols.has(key)) {\r\n        track(target, \"has\" /* HAS */, key);\r\n    }\r\n    return result;\r\n}\r\nfunction ownKeys(target) {\r\n    track(target, \"iterate\" /* ITERATE */, isArray(target) ? 'length' : ITERATE_KEY);\r\n    return Reflect.ownKeys(target);\r\n}\r\nconst mutableHandlers = {\r\n    get,\r\n    set,\r\n    deleteProperty,\r\n    has,\r\n    ownKeys\r\n};\r\nconst readonlyHandlers = {\r\n    get: readonlyGet,\r\n    set(target, key) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`Set operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n        }\r\n        return true;\r\n    },\r\n    deleteProperty(target, key) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`Delete operation on key \"${String(key)}\" failed: target is readonly.`, target);\r\n        }\r\n        return true;\r\n    }\r\n};\r\nconst shallowReactiveHandlers = extend({}, mutableHandlers, {\r\n    get: shallowGet,\r\n    set: shallowSet\r\n});\r\n// Props handlers are special in the sense that it should not unwrap top-level\r\n// refs (in order to allow refs to be explicitly passed down), but should\r\n// retain the reactivity of the normal readonly object.\r\nconst shallowReadonlyHandlers = extend({}, readonlyHandlers, {\r\n    get: shallowReadonlyGet\r\n});\n\nconst toReactive = (value) => isObject(value) ? reactive(value) : value;\r\nconst toReadonly = (value) => isObject(value) ? readonly(value) : value;\r\nconst toShallow = (value) => value;\r\nconst getProto = (v) => Reflect.getPrototypeOf(v);\r\nfunction get$1(target, key, isReadonly = false, isShallow = false) {\r\n    // #1772: readonly(reactive(Map)) should return readonly + reactive version\r\n    // of the value\r\n    target = target[\"__v_raw\" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (key !== rawKey) {\r\n        !isReadonly && track(rawTarget, \"get\" /* GET */, key);\r\n    }\r\n    !isReadonly && track(rawTarget, \"get\" /* GET */, rawKey);\r\n    const { has } = getProto(rawTarget);\r\n    const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\r\n    if (has.call(rawTarget, key)) {\r\n        return wrap(target.get(key));\r\n    }\r\n    else if (has.call(rawTarget, rawKey)) {\r\n        return wrap(target.get(rawKey));\r\n    }\r\n}\r\nfunction has$1(key, isReadonly = false) {\r\n    const target = this[\"__v_raw\" /* RAW */];\r\n    const rawTarget = toRaw(target);\r\n    const rawKey = toRaw(key);\r\n    if (key !== rawKey) {\r\n        !isReadonly && track(rawTarget, \"has\" /* HAS */, key);\r\n    }\r\n    !isReadonly && track(rawTarget, \"has\" /* HAS */, rawKey);\r\n    return key === rawKey\r\n        ? target.has(key)\r\n        : target.has(key) || target.has(rawKey);\r\n}\r\nfunction size(target, isReadonly = false) {\r\n    target = target[\"__v_raw\" /* RAW */];\r\n    !isReadonly && track(toRaw(target), \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n    return Reflect.get(target, 'size', target);\r\n}\r\nfunction add(value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const proto = getProto(target);\r\n    const hadKey = proto.has.call(target, value);\r\n    target.add(value);\r\n    if (!hadKey) {\r\n        trigger(target, \"add\" /* ADD */, value, value);\r\n    }\r\n    return this;\r\n}\r\nfunction set$1(key, value) {\r\n    value = toRaw(value);\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        checkIdentityKeys(target, has, key);\r\n    }\r\n    const oldValue = get.call(target, key);\r\n    target.set(key, value);\r\n    if (!hadKey) {\r\n        trigger(target, \"add\" /* ADD */, key, value);\r\n    }\r\n    else if (hasChanged(value, oldValue)) {\r\n        trigger(target, \"set\" /* SET */, key, value, oldValue);\r\n    }\r\n    return this;\r\n}\r\nfunction deleteEntry(key) {\r\n    const target = toRaw(this);\r\n    const { has, get } = getProto(target);\r\n    let hadKey = has.call(target, key);\r\n    if (!hadKey) {\r\n        key = toRaw(key);\r\n        hadKey = has.call(target, key);\r\n    }\r\n    else if ((process.env.NODE_ENV !== 'production')) {\r\n        checkIdentityKeys(target, has, key);\r\n    }\r\n    const oldValue = get ? get.call(target, key) : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.delete(key);\r\n    if (hadKey) {\r\n        trigger(target, \"delete\" /* DELETE */, key, undefined, oldValue);\r\n    }\r\n    return result;\r\n}\r\nfunction clear() {\r\n    const target = toRaw(this);\r\n    const hadItems = target.size !== 0;\r\n    const oldTarget = (process.env.NODE_ENV !== 'production')\r\n        ? isMap(target)\r\n            ? new Map(target)\r\n            : new Set(target)\r\n        : undefined;\r\n    // forward the operation before queueing reactions\r\n    const result = target.clear();\r\n    if (hadItems) {\r\n        trigger(target, \"clear\" /* CLEAR */, undefined, undefined, oldTarget);\r\n    }\r\n    return result;\r\n}\r\nfunction createForEach(isReadonly, isShallow) {\r\n    return function forEach(callback, thisArg) {\r\n        const observed = this;\r\n        const target = observed[\"__v_raw\" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\r\n        !isReadonly && track(rawTarget, \"iterate\" /* ITERATE */, ITERATE_KEY);\r\n        return target.forEach((value, key) => {\r\n            // important: make sure the callback is\r\n            // 1. invoked with the reactive map as `this` and 3rd arg\r\n            // 2. the value received should be a corresponding reactive/readonly.\r\n            return callback.call(thisArg, wrap(value), wrap(key), observed);\r\n        });\r\n    };\r\n}\r\nfunction createIterableMethod(method, isReadonly, isShallow) {\r\n    return function (...args) {\r\n        const target = this[\"__v_raw\" /* RAW */];\r\n        const rawTarget = toRaw(target);\r\n        const targetIsMap = isMap(rawTarget);\r\n        const isPair = method === 'entries' || (method === Symbol.iterator && targetIsMap);\r\n        const isKeyOnly = method === 'keys' && targetIsMap;\r\n        const innerIterator = target[method](...args);\r\n        const wrap = isReadonly ? toReadonly : isShallow ? toShallow : toReactive;\r\n        !isReadonly &&\r\n            track(rawTarget, \"iterate\" /* ITERATE */, isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);\r\n        // return a wrapped iterator which returns observed versions of the\r\n        // values emitted from the real iterator\r\n        return {\r\n            // iterator protocol\r\n            next() {\r\n                const { value, done } = innerIterator.next();\r\n                return done\r\n                    ? { value, done }\r\n                    : {\r\n                        value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),\r\n                        done\r\n                    };\r\n            },\r\n            // iterable protocol\r\n            [Symbol.iterator]() {\r\n                return this;\r\n            }\r\n        };\r\n    };\r\n}\r\nfunction createReadonlyMethod(type) {\r\n    return function (...args) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            const key = args[0] ? `on key \"${args[0]}\" ` : ``;\r\n            console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));\r\n        }\r\n        return type === \"delete\" /* DELETE */ ? false : this;\r\n    };\r\n}\r\nconst mutableInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key);\r\n    },\r\n    get size() {\r\n        return size(this);\r\n    },\r\n    has: has$1,\r\n    add,\r\n    set: set$1,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, false)\r\n};\r\nconst shallowInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key, false, true);\r\n    },\r\n    get size() {\r\n        return size(this);\r\n    },\r\n    has: has$1,\r\n    add,\r\n    set: set$1,\r\n    delete: deleteEntry,\r\n    clear,\r\n    forEach: createForEach(false, true)\r\n};\r\nconst readonlyInstrumentations = {\r\n    get(key) {\r\n        return get$1(this, key, true);\r\n    },\r\n    get size() {\r\n        return size(this, true);\r\n    },\r\n    has(key) {\r\n        return has$1.call(this, key, true);\r\n    },\r\n    add: createReadonlyMethod(\"add\" /* ADD */),\r\n    set: createReadonlyMethod(\"set\" /* SET */),\r\n    delete: createReadonlyMethod(\"delete\" /* DELETE */),\r\n    clear: createReadonlyMethod(\"clear\" /* CLEAR */),\r\n    forEach: createForEach(true, false)\r\n};\r\nconst iteratorMethods = ['keys', 'values', 'entries', Symbol.iterator];\r\niteratorMethods.forEach(method => {\r\n    mutableInstrumentations[method] = createIterableMethod(method, false, false);\r\n    readonlyInstrumentations[method] = createIterableMethod(method, true, false);\r\n    shallowInstrumentations[method] = createIterableMethod(method, false, true);\r\n});\r\nfunction createInstrumentationGetter(isReadonly, shallow) {\r\n    const instrumentations = shallow\r\n        ? shallowInstrumentations\r\n        : isReadonly\r\n            ? readonlyInstrumentations\r\n            : mutableInstrumentations;\r\n    return (target, key, receiver) => {\r\n        if (key === \"__v_isReactive\" /* IS_REACTIVE */) {\r\n            return !isReadonly;\r\n        }\r\n        else if (key === \"__v_isReadonly\" /* IS_READONLY */) {\r\n            return isReadonly;\r\n        }\r\n        else if (key === \"__v_raw\" /* RAW */) {\r\n            return target;\r\n        }\r\n        return Reflect.get(hasOwn(instrumentations, key) && key in target\r\n            ? instrumentations\r\n            : target, key, receiver);\r\n    };\r\n}\r\nconst mutableCollectionHandlers = {\r\n    get: createInstrumentationGetter(false, false)\r\n};\r\nconst shallowCollectionHandlers = {\r\n    get: createInstrumentationGetter(false, true)\r\n};\r\nconst readonlyCollectionHandlers = {\r\n    get: createInstrumentationGetter(true, false)\r\n};\r\nfunction checkIdentityKeys(target, has, key) {\r\n    const rawKey = toRaw(key);\r\n    if (rawKey !== key && has.call(target, rawKey)) {\r\n        const type = toRawType(target);\r\n        console.warn(`Reactive ${type} contains both the raw and reactive ` +\r\n            `versions of the same object${type === `Map` ? ` as keys` : ``}, ` +\r\n            `which can lead to inconsistencies. ` +\r\n            `Avoid differentiating between the raw and reactive versions ` +\r\n            `of an object and only use the reactive version if possible.`);\r\n    }\r\n}\n\nconst reactiveMap = new WeakMap();\r\nconst readonlyMap = new WeakMap();\r\nfunction targetTypeMap(rawType) {\r\n    switch (rawType) {\r\n        case 'Object':\r\n        case 'Array':\r\n            return 1 /* COMMON */;\r\n        case 'Map':\r\n        case 'Set':\r\n        case 'WeakMap':\r\n        case 'WeakSet':\r\n            return 2 /* COLLECTION */;\r\n        default:\r\n            return 0 /* INVALID */;\r\n    }\r\n}\r\nfunction getTargetType(value) {\r\n    return value[\"__v_skip\" /* SKIP */] || !Object.isExtensible(value)\r\n        ? 0 /* INVALID */\r\n        : targetTypeMap(toRawType(value));\r\n}\r\nfunction reactive(target) {\r\n    // if trying to observe a readonly proxy, return the readonly version.\r\n    if (target && target[\"__v_isReadonly\" /* IS_READONLY */]) {\r\n        return target;\r\n    }\r\n    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers);\r\n}\r\n/**\r\n * Return a shallowly-reactive copy of the original object, where only the root\r\n * level properties are reactive. It also does not auto-unwrap refs (even at the\r\n * root level).\r\n */\r\nfunction shallowReactive(target) {\r\n    return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers);\r\n}\r\n/**\r\n * Creates a readonly copy of the original object. Note the returned copy is not\r\n * made reactive, but `readonly` can be called on an already reactive object.\r\n */\r\nfunction readonly(target) {\r\n    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers);\r\n}\r\n/**\r\n * Returns a reactive-copy of the original object, where only the root level\r\n * properties are readonly, and does NOT unwrap refs nor recursively convert\r\n * returned properties.\r\n * This is used for creating the props proxy object for stateful components.\r\n */\r\nfunction shallowReadonly(target) {\r\n    return createReactiveObject(target, true, shallowReadonlyHandlers, readonlyCollectionHandlers);\r\n}\r\nfunction createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers) {\r\n    if (!isObject(target)) {\r\n        if ((process.env.NODE_ENV !== 'production')) {\r\n            console.warn(`value cannot be made reactive: ${String(target)}`);\r\n        }\r\n        return target;\r\n    }\r\n    // target is already a Proxy, return it.\r\n    // exception: calling readonly() on a reactive object\r\n    if (target[\"__v_raw\" /* RAW */] &&\r\n        !(isReadonly && target[\"__v_isReactive\" /* IS_REACTIVE */])) {\r\n        return target;\r\n    }\r\n    // target already has corresponding Proxy\r\n    const proxyMap = isReadonly ? readonlyMap : reactiveMap;\r\n    const existingProxy = proxyMap.get(target);\r\n    if (existingProxy) {\r\n        return existingProxy;\r\n    }\r\n    // only a whitelist of value types can be observed.\r\n    const targetType = getTargetType(target);\r\n    if (targetType === 0 /* INVALID */) {\r\n        return target;\r\n    }\r\n    const proxy = new Proxy(target, targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers);\r\n    proxyMap.set(target, proxy);\r\n    return proxy;\r\n}\r\nfunction isReactive(value) {\r\n    if (isReadonly(value)) {\r\n        return isReactive(value[\"__v_raw\" /* RAW */]);\r\n    }\r\n    return !!(value && value[\"__v_isReactive\" /* IS_REACTIVE */]);\r\n}\r\nfunction isReadonly(value) {\r\n    return !!(value && value[\"__v_isReadonly\" /* IS_READONLY */]);\r\n}\r\nfunction isProxy(value) {\r\n    return isReactive(value) || isReadonly(value);\r\n}\r\nfunction toRaw(observed) {\r\n    return ((observed && toRaw(observed[\"__v_raw\" /* RAW */])) || observed);\r\n}\r\nfunction markRaw(value) {\r\n    def(value, \"__v_skip\" /* SKIP */, true);\r\n    return value;\r\n}\n\nconst convert = (val) => isObject(val) ? reactive(val) : val;\r\nfunction isRef(r) {\r\n    return Boolean(r && r.__v_isRef === true);\r\n}\r\nfunction ref(value) {\r\n    return createRef(value);\r\n}\r\nfunction shallowRef(value) {\r\n    return createRef(value, true);\r\n}\r\nclass RefImpl {\r\n    constructor(_rawValue, _shallow = false) {\r\n        this._rawValue = _rawValue;\r\n        this._shallow = _shallow;\r\n        this.__v_isRef = true;\r\n        this._value = _shallow ? _rawValue : convert(_rawValue);\r\n    }\r\n    get value() {\r\n        track(toRaw(this), \"get\" /* GET */, 'value');\r\n        return this._value;\r\n    }\r\n    set value(newVal) {\r\n        if (hasChanged(toRaw(newVal), this._rawValue)) {\r\n            this._rawValue = newVal;\r\n            this._value = this._shallow ? newVal : convert(newVal);\r\n            trigger(toRaw(this), \"set\" /* SET */, 'value', newVal);\r\n        }\r\n    }\r\n}\r\nfunction createRef(rawValue, shallow = false) {\r\n    if (isRef(rawValue)) {\r\n        return rawValue;\r\n    }\r\n    return new RefImpl(rawValue, shallow);\r\n}\r\nfunction triggerRef(ref) {\r\n    trigger(toRaw(ref), \"set\" /* SET */, 'value', (process.env.NODE_ENV !== 'production') ? ref.value : void 0);\r\n}\r\nfunction unref(ref) {\r\n    return isRef(ref) ? ref.value : ref;\r\n}\r\nconst shallowUnwrapHandlers = {\r\n    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),\r\n    set: (target, key, value, receiver) => {\r\n        const oldValue = target[key];\r\n        if (isRef(oldValue) && !isRef(value)) {\r\n            oldValue.value = value;\r\n            return true;\r\n        }\r\n        else {\r\n            return Reflect.set(target, key, value, receiver);\r\n        }\r\n    }\r\n};\r\nfunction proxyRefs(objectWithRefs) {\r\n    return isReactive(objectWithRefs)\r\n        ? objectWithRefs\r\n        : new Proxy(objectWithRefs, shallowUnwrapHandlers);\r\n}\r\nclass CustomRefImpl {\r\n    constructor(factory) {\r\n        this.__v_isRef = true;\r\n        const { get, set } = factory(() => track(this, \"get\" /* GET */, 'value'), () => trigger(this, \"set\" /* SET */, 'value'));\r\n        this._get = get;\r\n        this._set = set;\r\n    }\r\n    get value() {\r\n        return this._get();\r\n    }\r\n    set value(newVal) {\r\n        this._set(newVal);\r\n    }\r\n}\r\nfunction customRef(factory) {\r\n    return new CustomRefImpl(factory);\r\n}\r\nfunction toRefs(object) {\r\n    if ((process.env.NODE_ENV !== 'production') && !isProxy(object)) {\r\n        console.warn(`toRefs() expects a reactive object but received a plain one.`);\r\n    }\r\n    const ret = isArray(object) ? new Array(object.length) : {};\r\n    for (const key in object) {\r\n        ret[key] = toRef(object, key);\r\n    }\r\n    return ret;\r\n}\r\nclass ObjectRefImpl {\r\n    constructor(_object, _key) {\r\n        this._object = _object;\r\n        this._key = _key;\r\n        this.__v_isRef = true;\r\n    }\r\n    get value() {\r\n        return this._object[this._key];\r\n    }\r\n    set value(newVal) {\r\n        this._object[this._key] = newVal;\r\n    }\r\n}\r\nfunction toRef(object, key) {\r\n    return isRef(object[key])\r\n        ? object[key]\r\n        : new ObjectRefImpl(object, key);\r\n}\n\nclass ComputedRefImpl {\r\n    constructor(getter, _setter, isReadonly) {\r\n        this._setter = _setter;\r\n        this._dirty = true;\r\n        this.__v_isRef = true;\r\n        this.effect = effect(getter, {\r\n            lazy: true,\r\n            scheduler: () => {\r\n                if (!this._dirty) {\r\n                    this._dirty = true;\r\n                    trigger(toRaw(this), \"set\" /* SET */, 'value');\r\n                }\r\n            }\r\n        });\r\n        this[\"__v_isReadonly\" /* IS_READONLY */] = isReadonly;\r\n    }\r\n    get value() {\r\n        if (this._dirty) {\r\n            this._value = this.effect();\r\n            this._dirty = false;\r\n        }\r\n        track(toRaw(this), \"get\" /* GET */, 'value');\r\n        return this._value;\r\n    }\r\n    set value(newValue) {\r\n        this._setter(newValue);\r\n    }\r\n}\r\nfunction computed(getterOrOptions) {\r\n    let getter;\r\n    let setter;\r\n    if (isFunction(getterOrOptions)) {\r\n        getter = getterOrOptions;\r\n        setter = (process.env.NODE_ENV !== 'production')\r\n            ? () => {\r\n                console.warn('Write operation failed: computed value is readonly');\r\n            }\r\n            : NOOP;\r\n    }\r\n    else {\r\n        getter = getterOrOptions.get;\r\n        setter = getterOrOptions.set;\r\n    }\r\n    return new ComputedRefImpl(getter, setter, isFunction(getterOrOptions) || !getterOrOptions.set);\r\n}\n\nexport { ITERATE_KEY, computed, customRef, effect, enableTracking, isProxy, isReactive, isReadonly, isRef, markRaw, pauseTracking, proxyRefs, reactive, readonly, ref, resetTracking, shallowReactive, shallowReadonly, shallowRef, stop, toRaw, toRef, toRefs, track, trigger, triggerRef, unref };\n","/**\r\n * Make a map and return a function for checking if a key\r\n * is in that map.\r\n * IMPORTANT: all calls of this function must be prefixed with\r\n * \\/\\*#\\_\\_PURE\\_\\_\\*\\/\r\n * So that rollup can tree-shake them if necessary.\r\n */\r\nfunction makeMap(str, expectsLowerCase) {\r\n    const map = Object.create(null);\r\n    const list = str.split(',');\r\n    for (let i = 0; i < list.length; i++) {\r\n        map[list[i]] = true;\r\n    }\r\n    return expectsLowerCase ? val => !!map[val.toLowerCase()] : val => !!map[val];\r\n}\n\n/**\r\n * dev only flag -> name mapping\r\n */\r\nconst PatchFlagNames = {\r\n    [1 /* TEXT */]: `TEXT`,\r\n    [2 /* CLASS */]: `CLASS`,\r\n    [4 /* STYLE */]: `STYLE`,\r\n    [8 /* PROPS */]: `PROPS`,\r\n    [16 /* FULL_PROPS */]: `FULL_PROPS`,\r\n    [32 /* HYDRATE_EVENTS */]: `HYDRATE_EVENTS`,\r\n    [64 /* STABLE_FRAGMENT */]: `STABLE_FRAGMENT`,\r\n    [128 /* KEYED_FRAGMENT */]: `KEYED_FRAGMENT`,\r\n    [256 /* UNKEYED_FRAGMENT */]: `UNKEYED_FRAGMENT`,\r\n    [512 /* NEED_PATCH */]: `NEED_PATCH`,\r\n    [1024 /* DYNAMIC_SLOTS */]: `DYNAMIC_SLOTS`,\r\n    [2048 /* DEV_ROOT_FRAGMENT */]: `DEV_ROOT_FRAGMENT`,\r\n    [-1 /* HOISTED */]: `HOISTED`,\r\n    [-2 /* BAIL */]: `BAIL`\r\n};\n\n/**\r\n * Dev only\r\n */\r\nconst slotFlagsText = {\r\n    [1 /* STABLE */]: 'STABLE',\r\n    [2 /* DYNAMIC */]: 'DYNAMIC',\r\n    [3 /* FORWARDED */]: 'FORWARDED'\r\n};\n\nconst GLOBALS_WHITE_LISTED = 'Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,' +\r\n    'decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,' +\r\n    'Object,Boolean,String,RegExp,Map,Set,JSON,Intl';\r\nconst isGloballyWhitelisted = /*#__PURE__*/ makeMap(GLOBALS_WHITE_LISTED);\n\nconst range = 2;\r\nfunction generateCodeFrame(source, start = 0, end = source.length) {\r\n    const lines = source.split(/\\r?\\n/);\r\n    let count = 0;\r\n    const res = [];\r\n    for (let i = 0; i < lines.length; i++) {\r\n        count += lines[i].length + 1;\r\n        if (count >= start) {\r\n            for (let j = i - range; j <= i + range || end > count; j++) {\r\n                if (j < 0 || j >= lines.length)\r\n                    continue;\r\n                const line = j + 1;\r\n                res.push(`${line}${' '.repeat(Math.max(3 - String(line).length, 0))}|  ${lines[j]}`);\r\n                const lineLength = lines[j].length;\r\n                if (j === i) {\r\n                    // push underline\r\n                    const pad = start - (count - lineLength) + 1;\r\n                    const length = Math.max(1, end > count ? lineLength - pad : end - start);\r\n                    res.push(`   |  ` + ' '.repeat(pad) + '^'.repeat(length));\r\n                }\r\n                else if (j > i) {\r\n                    if (end > count) {\r\n                        const length = Math.max(Math.min(end - count, lineLength), 1);\r\n                        res.push(`   |  ` + '^'.repeat(length));\r\n                    }\r\n                    count += lineLength + 1;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    }\r\n    return res.join('\\n');\r\n}\n\n/**\r\n * On the client we only need to offer special cases for boolean attributes that\r\n * have different names from their corresponding dom properties:\r\n * - itemscope -> N/A\r\n * - allowfullscreen -> allowFullscreen\r\n * - formnovalidate -> formNoValidate\r\n * - ismap -> isMap\r\n * - nomodule -> noModule\r\n * - novalidate -> noValidate\r\n * - readonly -> readOnly\r\n */\r\nconst specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;\r\nconst isSpecialBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs);\r\n/**\r\n * The full list is needed during SSR to produce the correct initial markup.\r\n */\r\nconst isBooleanAttr = /*#__PURE__*/ makeMap(specialBooleanAttrs +\r\n    `,async,autofocus,autoplay,controls,default,defer,disabled,hidden,` +\r\n    `loop,open,required,reversed,scoped,seamless,` +\r\n    `checked,muted,multiple,selected`);\r\nconst unsafeAttrCharRE = /[>/=\"'\\u0009\\u000a\\u000c\\u0020]/;\r\nconst attrValidationCache = {};\r\nfunction isSSRSafeAttrName(name) {\r\n    if (attrValidationCache.hasOwnProperty(name)) {\r\n        return attrValidationCache[name];\r\n    }\r\n    const isUnsafe = unsafeAttrCharRE.test(name);\r\n    if (isUnsafe) {\r\n        console.error(`unsafe attribute name: ${name}`);\r\n    }\r\n    return (attrValidationCache[name] = !isUnsafe);\r\n}\r\nconst propsToAttrMap = {\r\n    acceptCharset: 'accept-charset',\r\n    className: 'class',\r\n    htmlFor: 'for',\r\n    httpEquiv: 'http-equiv'\r\n};\r\n/**\r\n * CSS properties that accept plain numbers\r\n */\r\nconst isNoUnitNumericStyleProp = /*#__PURE__*/ makeMap(`animation-iteration-count,border-image-outset,border-image-slice,` +\r\n    `border-image-width,box-flex,box-flex-group,box-ordinal-group,column-count,` +\r\n    `columns,flex,flex-grow,flex-positive,flex-shrink,flex-negative,flex-order,` +\r\n    `grid-row,grid-row-end,grid-row-span,grid-row-start,grid-column,` +\r\n    `grid-column-end,grid-column-span,grid-column-start,font-weight,line-clamp,` +\r\n    `line-height,opacity,order,orphans,tab-size,widows,z-index,zoom,` +\r\n    // SVG\r\n    `fill-opacity,flood-opacity,stop-opacity,stroke-dasharray,stroke-dashoffset,` +\r\n    `stroke-miterlimit,stroke-opacity,stroke-width`);\r\n/**\r\n * Known attributes, this is used for stringification of runtime static nodes\r\n * so that we don't stringify bindings that cannot be set from HTML.\r\n * Don't also forget to allow `data-*` and `aria-*`!\r\n * Generated from https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\r\n */\r\nconst isKnownAttr = /*#__PURE__*/ makeMap(`accept,accept-charset,accesskey,action,align,allow,alt,async,` +\r\n    `autocapitalize,autocomplete,autofocus,autoplay,background,bgcolor,` +\r\n    `border,buffered,capture,challenge,charset,checked,cite,class,code,` +\r\n    `codebase,color,cols,colspan,content,contenteditable,contextmenu,controls,` +\r\n    `coords,crossorigin,csp,data,datetime,decoding,default,defer,dir,dirname,` +\r\n    `disabled,download,draggable,dropzone,enctype,enterkeyhint,for,form,` +\r\n    `formaction,formenctype,formmethod,formnovalidate,formtarget,headers,` +\r\n    `height,hidden,high,href,hreflang,http-equiv,icon,id,importance,integrity,` +\r\n    `ismap,itemprop,keytype,kind,label,lang,language,loading,list,loop,low,` +\r\n    `manifest,max,maxlength,minlength,media,min,multiple,muted,name,novalidate,` +\r\n    `open,optimum,pattern,ping,placeholder,poster,preload,radiogroup,readonly,` +\r\n    `referrerpolicy,rel,required,reversed,rows,rowspan,sandbox,scope,scoped,` +\r\n    `selected,shape,size,sizes,slot,span,spellcheck,src,srcdoc,srclang,srcset,` +\r\n    `start,step,style,summary,tabindex,target,title,translate,type,usemap,` +\r\n    `value,width,wrap`);\n\nfunction normalizeStyle(value) {\r\n    if (isArray(value)) {\r\n        const res = {};\r\n        for (let i = 0; i < value.length; i++) {\r\n            const item = value[i];\r\n            const normalized = normalizeStyle(isString(item) ? parseStringStyle(item) : item);\r\n            if (normalized) {\r\n                for (const key in normalized) {\r\n                    res[key] = normalized[key];\r\n                }\r\n            }\r\n        }\r\n        return res;\r\n    }\r\n    else if (isObject(value)) {\r\n        return value;\r\n    }\r\n}\r\nconst listDelimiterRE = /;(?![^(]*\\))/g;\r\nconst propertyDelimiterRE = /:(.+)/;\r\nfunction parseStringStyle(cssText) {\r\n    const ret = {};\r\n    cssText.split(listDelimiterRE).forEach(item => {\r\n        if (item) {\r\n            const tmp = item.split(propertyDelimiterRE);\r\n            tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());\r\n        }\r\n    });\r\n    return ret;\r\n}\r\nfunction stringifyStyle(styles) {\r\n    let ret = '';\r\n    if (!styles) {\r\n        return ret;\r\n    }\r\n    for (const key in styles) {\r\n        const value = styles[key];\r\n        const normalizedKey = key.startsWith(`--`) ? key : hyphenate(key);\r\n        if (isString(value) ||\r\n            (typeof value === 'number' && isNoUnitNumericStyleProp(normalizedKey))) {\r\n            // only render valid values\r\n            ret += `${normalizedKey}:${value};`;\r\n        }\r\n    }\r\n    return ret;\r\n}\r\nfunction normalizeClass(value) {\r\n    let res = '';\r\n    if (isString(value)) {\r\n        res = value;\r\n    }\r\n    else if (isArray(value)) {\r\n        for (let i = 0; i < value.length; i++) {\r\n            res += normalizeClass(value[i]) + ' ';\r\n        }\r\n    }\r\n    else if (isObject(value)) {\r\n        for (const name in value) {\r\n            if (value[name]) {\r\n                res += name + ' ';\r\n            }\r\n        }\r\n    }\r\n    return res.trim();\r\n}\n\n// These tag configs are shared between compiler-dom and runtime-dom, so they\r\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element\r\nconst HTML_TAGS = 'html,body,base,head,link,meta,style,title,address,article,aside,footer,' +\r\n    'header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,' +\r\n    'figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,' +\r\n    'data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,' +\r\n    'time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,' +\r\n    'canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,' +\r\n    'th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,' +\r\n    'option,output,progress,select,textarea,details,dialog,menu,' +\r\n    'summary,template,blockquote,iframe,tfoot';\r\n// https://developer.mozilla.org/en-US/docs/Web/SVG/Element\r\nconst SVG_TAGS = 'svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,' +\r\n    'defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,' +\r\n    'feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,' +\r\n    'feDistanceLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,' +\r\n    'feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,' +\r\n    'fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,' +\r\n    'foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,' +\r\n    'mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,' +\r\n    'polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,' +\r\n    'text,textPath,title,tspan,unknown,use,view';\r\nconst VOID_TAGS = 'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr';\r\nconst isHTMLTag = /*#__PURE__*/ makeMap(HTML_TAGS);\r\nconst isSVGTag = /*#__PURE__*/ makeMap(SVG_TAGS);\r\nconst isVoidTag = /*#__PURE__*/ makeMap(VOID_TAGS);\n\nconst escapeRE = /[\"'&<>]/;\r\nfunction escapeHtml(string) {\r\n    const str = '' + string;\r\n    const match = escapeRE.exec(str);\r\n    if (!match) {\r\n        return str;\r\n    }\r\n    let html = '';\r\n    let escaped;\r\n    let index;\r\n    let lastIndex = 0;\r\n    for (index = match.index; index < str.length; index++) {\r\n        switch (str.charCodeAt(index)) {\r\n            case 34: // \"\r\n                escaped = '&quot;';\r\n                break;\r\n            case 38: // &\r\n                escaped = '&amp;';\r\n                break;\r\n            case 39: // '\r\n                escaped = '&#39;';\r\n                break;\r\n            case 60: // <\r\n                escaped = '&lt;';\r\n                break;\r\n            case 62: // >\r\n                escaped = '&gt;';\r\n                break;\r\n            default:\r\n                continue;\r\n        }\r\n        if (lastIndex !== index) {\r\n            html += str.substring(lastIndex, index);\r\n        }\r\n        lastIndex = index + 1;\r\n        html += escaped;\r\n    }\r\n    return lastIndex !== index ? html + str.substring(lastIndex, index) : html;\r\n}\r\n// https://www.w3.org/TR/html52/syntax.html#comments\r\nconst commentStripRE = /^-?>|<!--|-->|--!>|<!-$/g;\r\nfunction escapeHtmlComment(src) {\r\n    return src.replace(commentStripRE, '');\r\n}\n\nfunction looseCompareArrays(a, b) {\r\n    if (a.length !== b.length)\r\n        return false;\r\n    let equal = true;\r\n    for (let i = 0; equal && i < a.length; i++) {\r\n        equal = looseEqual(a[i], b[i]);\r\n    }\r\n    return equal;\r\n}\r\nfunction looseEqual(a, b) {\r\n    if (a === b)\r\n        return true;\r\n    let aValidType = isDate(a);\r\n    let bValidType = isDate(b);\r\n    if (aValidType || bValidType) {\r\n        return aValidType && bValidType ? a.getTime() === b.getTime() : false;\r\n    }\r\n    aValidType = isArray(a);\r\n    bValidType = isArray(b);\r\n    if (aValidType || bValidType) {\r\n        return aValidType && bValidType ? looseCompareArrays(a, b) : false;\r\n    }\r\n    aValidType = isObject(a);\r\n    bValidType = isObject(b);\r\n    if (aValidType || bValidType) {\r\n        /* istanbul ignore if: this if will probably never be called */\r\n        if (!aValidType || !bValidType) {\r\n            return false;\r\n        }\r\n        const aKeysCount = Object.keys(a).length;\r\n        const bKeysCount = Object.keys(b).length;\r\n        if (aKeysCount !== bKeysCount) {\r\n            return false;\r\n        }\r\n        for (const key in a) {\r\n            const aHasKey = a.hasOwnProperty(key);\r\n            const bHasKey = b.hasOwnProperty(key);\r\n            if ((aHasKey && !bHasKey) ||\r\n                (!aHasKey && bHasKey) ||\r\n                !looseEqual(a[key], b[key])) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return String(a) === String(b);\r\n}\r\nfunction looseIndexOf(arr, val) {\r\n    return arr.findIndex(item => looseEqual(item, val));\r\n}\n\n/**\r\n * For converting {{ interpolation }} values to displayed strings.\r\n * @private\r\n */\r\nconst toDisplayString = (val) => {\r\n    return val == null\r\n        ? ''\r\n        : isObject(val)\r\n            ? JSON.stringify(val, replacer, 2)\r\n            : String(val);\r\n};\r\nconst replacer = (_key, val) => {\r\n    if (isMap(val)) {\r\n        return {\r\n            [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val]) => {\r\n                entries[`${key} =>`] = val;\r\n                return entries;\r\n            }, {})\r\n        };\r\n    }\r\n    else if (isSet(val)) {\r\n        return {\r\n            [`Set(${val.size})`]: [...val.values()]\r\n        };\r\n    }\r\n    else if (isObject(val) && !isArray(val) && !isPlainObject(val)) {\r\n        return String(val);\r\n    }\r\n    return val;\r\n};\n\n/**\r\n * List of @babel/parser plugins that are used for template expression\r\n * transforms and SFC script transforms. By default we enable proposals slated\r\n * for ES2020. This will need to be updated as the spec moves forward.\r\n * Full list at https://babeljs.io/docs/en/next/babel-parser#plugins\r\n */\r\nconst babelParserDefaultPlugins = [\r\n    'bigInt',\r\n    'optionalChaining',\r\n    'nullishCoalescingOperator'\r\n];\r\nconst EMPTY_OBJ = (process.env.NODE_ENV !== 'production')\r\n    ? Object.freeze({})\r\n    : {};\r\nconst EMPTY_ARR = (process.env.NODE_ENV !== 'production') ? Object.freeze([]) : [];\r\nconst NOOP = () => { };\r\n/**\r\n * Always return false.\r\n */\r\nconst NO = () => false;\r\nconst onRE = /^on[^a-z]/;\r\nconst isOn = (key) => onRE.test(key);\r\nconst isModelListener = (key) => key.startsWith('onUpdate:');\r\nconst extend = Object.assign;\r\nconst remove = (arr, el) => {\r\n    const i = arr.indexOf(el);\r\n    if (i > -1) {\r\n        arr.splice(i, 1);\r\n    }\r\n};\r\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\r\nconst hasOwn = (val, key) => hasOwnProperty.call(val, key);\r\nconst isArray = Array.isArray;\r\nconst isMap = (val) => toTypeString(val) === '[object Map]';\r\nconst isSet = (val) => toTypeString(val) === '[object Set]';\r\nconst isDate = (val) => val instanceof Date;\r\nconst isFunction = (val) => typeof val === 'function';\r\nconst isString = (val) => typeof val === 'string';\r\nconst isSymbol = (val) => typeof val === 'symbol';\r\nconst isObject = (val) => val !== null && typeof val === 'object';\r\nconst isPromise = (val) => {\r\n    return isObject(val) && isFunction(val.then) && isFunction(val.catch);\r\n};\r\nconst objectToString = Object.prototype.toString;\r\nconst toTypeString = (value) => objectToString.call(value);\r\nconst toRawType = (value) => {\r\n    // extract \"RawType\" from strings like \"[object RawType]\"\r\n    return toTypeString(value).slice(8, -1);\r\n};\r\nconst isPlainObject = (val) => toTypeString(val) === '[object Object]';\r\nconst isIntegerKey = (key) => isString(key) &&\r\n    key !== 'NaN' &&\r\n    key[0] !== '-' &&\r\n    '' + parseInt(key, 10) === key;\r\nconst isReservedProp = /*#__PURE__*/ makeMap(\r\n// the leading comma is intentional so empty string \"\" is also included\r\n',key,ref,' +\r\n    'onVnodeBeforeMount,onVnodeMounted,' +\r\n    'onVnodeBeforeUpdate,onVnodeUpdated,' +\r\n    'onVnodeBeforeUnmount,onVnodeUnmounted');\r\nconst cacheStringFunction = (fn) => {\r\n    const cache = Object.create(null);\r\n    return ((str) => {\r\n        const hit = cache[str];\r\n        return hit || (cache[str] = fn(str));\r\n    });\r\n};\r\nconst camelizeRE = /-(\\w)/g;\r\n/**\r\n * @private\r\n */\r\nconst camelize = cacheStringFunction((str) => {\r\n    return str.replace(camelizeRE, (_, c) => (c ? c.toUpperCase() : ''));\r\n});\r\nconst hyphenateRE = /\\B([A-Z])/g;\r\n/**\r\n * @private\r\n */\r\nconst hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, '-$1').toLowerCase());\r\n/**\r\n * @private\r\n */\r\nconst capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));\r\n/**\r\n * @private\r\n */\r\nconst toHandlerKey = cacheStringFunction((str) => (str ? `on${capitalize(str)}` : ``));\r\n// compare whether a value has changed, accounting for NaN.\r\nconst hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);\r\nconst invokeArrayFns = (fns, arg) => {\r\n    for (let i = 0; i < fns.length; i++) {\r\n        fns[i](arg);\r\n    }\r\n};\r\nconst def = (obj, key, value) => {\r\n    Object.defineProperty(obj, key, {\r\n        configurable: true,\r\n        enumerable: false,\r\n        value\r\n    });\r\n};\r\nconst toNumber = (val) => {\r\n    const n = parseFloat(val);\r\n    return isNaN(n) ? val : n;\r\n};\r\nlet _globalThis;\r\nconst getGlobalThis = () => {\r\n    return (_globalThis ||\r\n        (_globalThis =\r\n            typeof globalThis !== 'undefined'\r\n                ? globalThis\r\n                : typeof self !== 'undefined'\r\n                    ? self\r\n                    : typeof window !== 'undefined'\r\n                        ? window\r\n                        : typeof global !== 'undefined'\r\n                            ? global\r\n                            : {}));\r\n};\n\nexport { EMPTY_ARR, EMPTY_OBJ, NO, NOOP, PatchFlagNames, babelParserDefaultPlugins, camelize, capitalize, def, escapeHtml, escapeHtmlComment, extend, generateCodeFrame, getGlobalThis, hasChanged, hasOwn, hyphenate, invokeArrayFns, isArray, isBooleanAttr, isDate, isFunction, isGloballyWhitelisted, isHTMLTag, isIntegerKey, isKnownAttr, isMap, isModelListener, isNoUnitNumericStyleProp, isObject, isOn, isPlainObject, isPromise, isReservedProp, isSSRSafeAttrName, isSVGTag, isSet, isSpecialBooleanAttr, isString, isSymbol, isVoidTag, looseEqual, looseIndexOf, makeMap, normalizeClass, normalizeStyle, objectToString, parseStringStyle, propsToAttrMap, remove, slotFlagsText, stringifyStyle, toDisplayString, toHandlerKey, toNumber, toRawType, toTypeString };\n","import { render } from \"uhtml\";\nimport { reactive, effect } from \"@vue/reactivity\";\n\nlet currentInstance;\n\nconst createLifecycleMethod = (name) => (hook) => {\n  if (currentInstance) {\n    (currentInstance[name] || (currentInstance[name] = [])).push(hook);\n  }\n};\n\nconst runLifeCycleMethod = (hooks) => {\n  hooks && hooks.forEach((hook) => hook());\n};\n\nexport const beforeCreate = createLifecycleMethod(\"hookBeforeCreate\");\nexport const created = createLifecycleMethod(\"hookCreated\");\nexport const beforeMount = createLifecycleMethod(\"hookBeforeMount\");\nexport const mounted = createLifecycleMethod(\"hookMounted\");\nexport const beforeUpdate = createLifecycleMethod(\"hookBeforeUpdate\");\nexport const updated = createLifecycleMethod(\"hookUpdated\");\nexport const unmounted = createLifecycleMethod(\"hookUnmounted\");\n\nexport const useEmit = (ctx) => (event) => {\n  ctx.dispatchEvent(event);\n};\n\nexport const defineComponent = ({\n  name,\n  setup,\n  propDefs = [],\n  useShadowDOM = true,\n}) => {\n  customElements.define(\n    name,\n    class extends HTMLElement {\n      static get observedAttributes() {\n        return propDefs;\n      }\n\n      constructor() {\n        super();\n\n        // Execute beforeCreate hook\n        runLifeCycleMethod(this.hookBeforeCreate);\n\n        currentInstance = this;\n\n        // Execute created hook\n        runLifeCycleMethod(this.hookCreated);\n\n        const props = (this.props = reactive({}));\n        propDefs.forEach((key) => {\n          Object.defineProperty(this, key, {\n            get() {\n              return this.props[key];\n            },\n            set(value) {\n              this.props[key] = value;\n            },\n          });\n        });\n\n        const slots = useShadowDOM ? (this.slots = reactive({})) : undefined;\n\n        const template = (this.template = setup.call(this, {\n          props,\n          ctx: this,\n          emit: useEmit(this),\n          refs: reactive({}),\n          ...(slots ? { slots } : {}),\n        }));\n\n        this.useShadowDOM = useShadowDOM;\n        const root = (this.root = useShadowDOM\n          ? this.attachShadow({ mode: \"closed\" })\n          : this);\n\n        this.render = () => {\n          render(root, template());\n        };\n\n        // Execute beforeMount hook\n        runLifeCycleMethod(this.hookBeforeMount);\n        this.isMounted = false;\n\n        this.effectCallback = () => {\n          if (this.isMounted) {\n            runLifeCycleMethod(this.hookBeforeUpdate);\n          }\n\n          this.render();\n\n          if (this.isMounted) {\n            // Execute updated hook\n            runLifeCycleMethod(this.hookUpdated);\n          } else {\n            this.isMounted = true;\n          }\n        };\n\n        if (useShadowDOM) {\n          effect(this.effectCallback);\n        }\n\n        currentInstance = null;\n      }\n\n      connectedCallback() {\n        if (!this.useShadowDOM) {\n          effect(this.effectCallback);\n        }\n\n        // Execute mounted hook\n        runLifeCycleMethod(this.hookMounted);\n\n        if (this.useShadowDOM) {\n          this.querySelectorAll(\"[slot]\").forEach((slot) => {\n            this.slots[slot.getAttribute(\"slot\")] = slot;\n          });\n        }\n      }\n\n      disconnectedCallback() {\n        // Execute unmounted hook\n        runLifeCycleMethod(this.hookUnmounted);\n      }\n\n      attributeChangedCallback(name, oldValue, newValue) {\n        let val;\n        try {\n          val = JSON.parse(newValue);\n        } catch (e) {\n          val = newValue;\n        }\n        this[name] = val;\n      }\n    }\n  );\n};\n\nexport * from \"uhtml\";\nexport * from \"@vue/reactivity\";\n"],"names":["_","get","key","set","value","attr","empty","node","notNode","selfClosing","trimEnd","isNode","template","i","test","regular","original","name","extra","replace","isArray","Array","indexOf","slice","diffable","operation","nodeType","firstChild","lastChild","range","document","createRange","setStartAfter","setEndAfter","deleteContents","remove","valueOf","createContent","FRAGMENT","TEMPLATE","createHTML","create","html","innerHTML","content","childNodes","selector","RegExp","$1","querySelectorAll","append","markup","type","createSVG","root","length","appendChild","element","createDocumentFragment","createElementNS","svg","reducePath","createPath","path","parentNode","push","call","createTreeWalker","importNode","isImportNodeLengthWrong","createFragment","text","normalize","createWalker","fragment","diff","comment","oldNodes","newNodes","a","b","before","bLength","aEnd","bEnd","aStart","bStart","map","nextSibling","insertBefore","has","removeChild","Map","index","sequence","replaceChild","udomdiff","handleAttribute","oldValue","newValue","setAttribute","removeAttribute","boolean","dataset","values","data","setter","toLowerCase","info","removeEventListener","addEventListener","event","current","ref","aria","orphan","attributeNode","createAttributeNS","removeAttributeNode","setAttributeNodeNS","attribute","handlers","options","reduceRight","this","nodes","anyContent","nodeValue","createTextNode","String","handleAnything","textContent","cache","umap","WeakMap","textOnly","mapTemplate","prefix","chunk","$2","output","join","trim","instrument","tw","search","nextNode","hasAttribute","getAttribute","tagName","mapUpdates","updates","unroll","unrollValues","entry","wire","createEntry","ELEMENT_NODE","persistent","stack","hole","Hole","splice","activeEffect","defineProperties","Object","tag","keyed","for","id","memo","fixed","render","where","what","EMPTY_OBJ","NOOP","extend","assign","hasOwnProperty","prototype","hasOwn","val","isMap","toTypeString","isFunction","isSymbol","isObject","objectToString","toString","isIntegerKey","parseInt","hasChanged","targetMap","effectStack","ITERATE_KEY","Symbol","MAP_KEY_ITERATE_KEY","isEffect","fn","_isEffect","effect","raw","createReactiveEffect","lazy","uid","active","scheduler","undefined","includes","cleanup","enableTracking","pop","resetTracking","allowRecurse","deps","delete","shouldTrack","trackStack","pauseTracking","last","track","target","depsMap","dep","Set","add","trigger","oldTarget","effects","effectsToAdd","forEach","builtInSymbols","getOwnPropertyNames","filter","createGetter","shallowGet","readonlyGet","shallowReadonlyGet","arrayInstrumentations","isReadonly","shallow","receiver","readonlyMap","reactiveMap","targetIsArray","Reflect","res","isRef","readonly","reactive","createSetter","toRaw","hadKey","Number","result","method","arr","l","args","apply","mutableHandlers","deleteProperty","ownKeys","readonlyHandlers","shallowReactiveHandlers","shallowReadonlyHandlers","toReactive","toReadonly","toShallow","getProto","v","getPrototypeOf","get$1","isShallow","rawTarget","rawKey","wrap","has$1","size","set$1","deleteEntry","clear","hadItems","createForEach","callback","thisArg","observed","createIterableMethod","targetIsMap","isPair","iterator","isKeyOnly","innerIterator","next","done","createReadonlyMethod","mutableInstrumentations","shallowInstrumentations","readonlyInstrumentations","createInstrumentationGetter","instrumentations","mutableCollectionHandlers","shallowCollectionHandlers","readonlyCollectionHandlers","getTargetType","isExtensible","rawType","targetTypeMap","toRawType","createReactiveObject","baseHandlers","collectionHandlers","proxyMap","existingProxy","targetType","proxy","Proxy","isReactive","convert","r","Boolean","__v_isRef","RefImpl","constructor","_rawValue","_shallow","_value","newVal","createRef","rawValue","unref","currentInstance","shallowUnwrapHandlers","CustomRefImpl","factory","_get","_set","ObjectRefImpl","_object","_key","toRef","object","ComputedRefImpl","getter","_setter","_dirty","createLifecycleMethod","hook","runLifeCycleMethod","hooks","beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","unmounted","useEmit","ctx","dispatchEvent","getterOrOptions","setup","propDefs","useShadowDOM","customElements","define","HTMLElement","hookBeforeCreate","hookCreated","props","defineProperty","slots","emit","refs","attachShadow","mode","hookBeforeMount","isMounted","effectCallback","hookBeforeUpdate","hookUpdated","connectedCallback","hookMounted","slot","disconnectedCallback","hookUnmounted","attributeChangedCallback","JSON","parse","e","obj","configurable","enumerable","def","objectWithRefs","onStop","ret"],"mappings":"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"}